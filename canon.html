<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>FUEGO G√ÅSTRICO</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0f0f1b;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: monospace;
    color: #e8e8e8;
  }
  h1 {
    font-size: 42px;
    color: #f5c542;
    letter-spacing: 8px;
    text-transform: uppercase;
    margin-bottom: 6px;
    text-shadow: 3px 3px #a0801a, 0 0 18px #f5c54288;
  }
  #subtitle {
    font-size: 12px;
    color: #aaaacc;
    letter-spacing: 4px;
    margin-bottom: 16px;
  }
  canvas {
    border: 2px solid #4a5a7c;
    image-rendering: pixelated;
    display: block;
    max-width: 100%;
  }
  #hud {
    display: flex;
    justify-content: space-between;
    width: 1400px;
    max-width: 100%;
    margin-top: 10px;
    font-size: 13px;
    letter-spacing: 2px;
    color: #aaaacc;
  }
  #hud span { color: #f5c542; }
  #panel {
    margin-top: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  #panel label { font-size: 13px; letter-spacing: 1px; color: #c0c0e0; }
  #angle-input {
    background: #1a1a2e;
    border: 2px solid #3a3a5c;
    color: #f5c542;
    font-family: monospace;
    font-size: 20px;
    width: 80px;
    text-align: center;
    padding: 4px;
    outline: none;
  }
  #angle-input:focus { border-color: #f5c542; }
  #fire-btn {
    background: #8b1a1a;
    border: 2px solid #cc3333;
    border-radius: 4px;
    color: #fff;
    font-family: monospace;
    font-size: 15px;
    letter-spacing: 2px;
    padding: 8px 22px;
    cursor: pointer;
    text-transform: uppercase;
    user-select: none;
  }
  #fire-btn:hover:not(:disabled) { background: #cc3333; }
  #fire-btn:disabled { opacity: 0.4; cursor: default; }
  #message {
    margin-top: 10px;
    font-size: 14px;
    letter-spacing: 2px;
    min-height: 22px;
    color: #e8e8e8;
    text-align: center;
  }
  #restart-btn {
    display: none;
    margin-top: 10px;
    background: #1a5c1a;
    border: 2px solid #33cc33;
    border-radius: 4px;
    color: #fff;
    font-family: monospace;
    font-size: 14px;
    letter-spacing: 2px;
    padding: 8px 28px;
    cursor: pointer;
    text-transform: uppercase;
  }
  #restart-btn:hover { background: #33cc33; }

  /* Barra de potencia */
  #power-bar-wrap {
    margin-top: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    letter-spacing: 2px;
    color: #c0c0e0;
    width: 1400px;
    max-width: 100%;
  }
  #power-bar-track {
    flex: 1;
    height: 18px;
    background: #1a1a2e;
    border: 2px solid #4a5a7c;
    border-radius: 3px;
    position: relative;
    overflow: hidden;
  }
  #power-bar-fill {
    height: 100%;
    width: 0%;
    background: #444;
    transition: none;
  }
  #power-pct {
    min-width: 38px;
    text-align: right;
    color: #aaaacc;
  }
</style>
</head>
<body>

<h1>&#x1F525; FUEGO G√ÅSTRICO</h1>
<div id="subtitle">LOW-BIT FLATULENCE</div>

<canvas id="cv" width="1400" height="580"></canvas>

<div id="hud">
  <div>OBJETIVOS: <span id="hud-obj">3</span></div>
  <div>TIROS: <span id="hud-shots">5</span></div>
  <div>POTENCIA: <span id="hud-power">0%</span></div>
  <div>DISTANCIA: <span id="hud-dist">???</span>m</div>
</div>

<div id="panel">
  <label>√ÅNGULO:</label>
  <input id="angle-input" type="number" min="1" max="89" value="45" step="1">
  <button id="fire-btn">&#x1F4A8; ¬°FUEGO!</button>
</div>

<div id="power-bar-wrap">
  <span>POTENCIA:</span>
  <div id="power-bar-track">
    <div id="power-bar-fill"></div>
  </div>
  <span id="power-pct">0%</span>
</div>

<div id="message">Mant√©n ESPACIO o el bot√≥n para cargar y suelta para disparar</div>
<button id="restart-btn">&#x21BA; OTRA VEZ</button>

<script>
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
ctx.imageSmoothingEnabled = false;


// Estado del juego
let state = {};

function initGame() {
  state = {
    objetivos: 3,
    oportunidades: 5,
    fase: 'apuntando', // apuntando | disparando | resultado
    alcance: 0,
    distObj: 0,
    objDestruido: false,
    particulas: [],
    proj: null,
    angulo: 45,
    disparoNum: 0,
    gameOver: false,
    victoria: false,
    shotsTotal: 0,
    power: 0,
    charging: false,
    chargeStart: null,
  };
  newObjective();
}

function newObjective() {
  state.oportunidades = 5;
  state.objDestruido = false;
  state.alcance = 10000 + Math.random() * 40000;
  state.distObj = 5000 + Math.random() * (state.alcance - 5000);
  state.particulas = [];
  state.proj = null;
  state.fase = 'apuntando';
  state.power = 0;
  state.charging = false;
  state.chargeStart = null;
  updateHUD();
  updatePowerBar();
  setMessage('Objetivo a <span style="color:#44aaff">' + Math.round(state.distObj) + 'm</span>. Mant√©n ESPACIO para cargar potencia.');
  document.getElementById('hud-dist').textContent = Math.round(state.distObj) + 'm';
  enableInput(true);
}

function updateHUD() {
  document.getElementById('hud-obj').textContent = state.objetivos;
  document.getElementById('hud-shots').textContent = state.oportunidades;
}

function updatePowerBar() {
  const pct = Math.round(state.power * 100);
  const fill = document.getElementById('power-bar-fill');
  const pctEl = document.getElementById('power-pct');
  const hudPower = document.getElementById('hud-power');

  fill.style.width = pct + '%';

  // Color seg√∫n nivel
  if (state.charging) {
    if (pct <= 40) {
      fill.style.background = '#33cc33';
    } else if (pct <= 70) {
      fill.style.background = '#f5c542';
    } else {
      fill.style.background = '#cc3333';
    }
  } else {
    fill.style.background = '#555577';
  }

  pctEl.textContent = pct + '%';
  hudPower.textContent = pct + '%';
}

function setMessage(html) {
  document.getElementById('message').innerHTML = html;
}

function enableInput(on) {
  document.getElementById('angle-input').disabled = !on;
  document.getElementById('fire-btn').disabled = !on;
}

// F√≠sica
const G = 9.8;
const CANNON_X = 60;
const GROUND_Y = 460;
const CV_W = 1400;
const CV_H = 580;

function worldToScreen(dist) {
  return CANNON_X + (dist / state.alcance) * (CV_W - 20 - CANNON_X);
}

function fire(angleDeg) {
  const MAX_V0 = Math.sqrt(state.alcance * G);
  const power = Math.max(state.power, 0.05); // m√≠nimo 5%
  const v0 = power * MAX_V0;
  const rad = angleDeg * Math.PI / 180;
  const vx = v0 * Math.cos(rad);
  const vy = v0 * Math.sin(rad);
  const tiempoVuelo = (2 * vy) / G;
  const alcanceReal = vx * tiempoVuelo;

  state.proj = {
    t: 0,
    tMax: tiempoVuelo,
    vx, vy,
    alcanceReal,
    angleDeg,
    x: CANNON_X,
    y: GROUND_Y,
    trail: [],
    exploded: false,
  };
  soundFire();
  state.fase = 'disparando';
  state.charging = false;
  enableInput(false);
  animating = true;
}

function startCharge() {
  if (state.fase !== 'apuntando') return;
  if (state.charging) return;
  state.charging = true;
  state.chargeStart = Date.now();
}

function releaseAndFire() {
  if (!state.charging) return;
  state.charging = false;
  if (state.fase !== 'apuntando') return;
  const a = parseFloat(document.getElementById('angle-input').value);
  if (isNaN(a) || a < 0.5 || a > 89.5) {
    setMessage('<span style="color:#ff8800">√Ångulo debe estar entre 1¬∞ y 89¬∞.</span>');
    return;
  }
  state.angulo = a;
  fire(a);
  lastTime = null;
  requestAnimationFrame(animate);
}

// Animaci√≥n
let animating = false;
let lastTime = null;

function animate(ts) {
  if (!animating) return;
  if (!lastTime) lastTime = ts;
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  update(dt);
  draw();
  requestAnimationFrame(animate);
}

function update(dt) {
  // Actualizar potencia si est√° cargando
  if (state.charging && state.chargeStart !== null) {
    const elapsed = (Date.now() - state.chargeStart) / 1000;
    state.power = Math.min(elapsed / 1.25, 1.0);
    updatePowerBar();
  }

  updateParticulas(dt);

  if (state.fase !== 'disparando' || !state.proj) return;
  const p = state.proj;
  p.t += dt * 67.5;

  const t = p.t;
  const rx = p.vx * t;
  const ry = p.vy * t - 0.5 * G * t * t;

  p.x = worldToScreen(rx);
  p.y = GROUND_Y - (ry / state.alcance) * (GROUND_Y - 40);

  p.trail.push({ x: p.x, y: p.y, a: 0.8 });
  if (p.trail.length > 28) p.trail.shift();

  // Colisi√≥n con el inodoro flotante (hitbox en coordenadas de pantalla)
  if (!state.objDestruido) {
    const floatY  = Math.sin(Date.now() / 700) * 10;
    const ttx     = worldToScreen(state.distObj);
    const tcy     = GROUND_Y - 80 + floatY; // base del inodoro (updated for larger canvas)
    const inX     = p.x >= ttx - 16 && p.x <= ttx + 16;
    const inY     = p.y >= tcy - 90 && p.y <= tcy + 2;
    if (inX && inY) {
      spawnExplosion(Math.round(p.x), Math.round(p.y), true);
      soundHit();
      state.proj  = null;
      state.fase  = 'resultado';
      state.oportunidades--;
      state.shotsTotal++;
      setTimeout(() => {
        state.objDestruido = true;
        setMessage('<span style="color:#33ff33">&#x1F4A9; ¬°OBJETIVO ALCANZADO!</span>');
        setTimeout(() => nextPhase(true), 1500);
      }, 600);
      return;
    }
  }

  // Toc√≥ el suelo ‚Üí siempre fallo (el inodoro est√° en el aire)
  if (p.t > 0 && (t >= p.tMax || p.y >= GROUND_Y)) {
    p.y = GROUND_Y;
    const impactoMetros = p.alcanceReal;
    const diff   = impactoMetros - state.distObj;
    const dir    = diff > 0 ? 'pasaste' : 'te quedaste corto';
    const errMsg = `Error: ${Math.round(Math.abs(diff))}m (${dir})`;

    spawnExplosion(p.x, GROUND_Y, false);
    soundMiss();
    state.proj  = null;
    state.fase  = 'resultado';
    state.oportunidades--;
    state.shotsTotal++;

    setTimeout(() => {
      if (state.oportunidades <= 0) {
        setMessage(`<span style="color:#ff4444">&#x2716; Sin tiros. ${errMsg}</span>`);
        setTimeout(() => nextPhase(false), 1500);
      } else {
        setMessage(`<span style="color:#ffaa44">&#x25CB; Fallo. ${errMsg} ‚Äî ${state.oportunidades} tiro(s) restantes.</span>`);
        state.fase = 'apuntando';
        state.power = 0;
        state.charging = false;
        state.chargeStart = null;
        updateHUD();
        updatePowerBar();
        enableInput(true);
      }
    }, 600);
  }
}

function nextPhase(exito) {
  if (!exito) {
    state.objetivos--;
  } else {
    state.objetivos--;
  }
  updateHUD();
  if (state.objetivos <= 0) {
    if (exito || state.objDestruido) {
      endGame(true);
    } else {
      endGame(false);
    }
    return;
  }
  if (!exito && !state.objDestruido) {
    // contin√∫a pero con objetivos perdidos
  }
  newObjective();
}

function endGame(victoria) {
  state.gameOver = true;
  state.victoria = victoria;
  state.charging = false;
  enableInput(false);
  animating = false;
  draw();
  if (victoria) {
    soundVictory();
    setMessage('<span style="color:#f5c542">&#x1F4A9; ¬°VICTORIA! Todo embarrado.</span>');
  } else {
    soundDefeat();
    setMessage('<span style="color:#ff4444">&#x1F4A8; DERROTA. P√≥lvora desperdiciada.</span>');
  }
  document.getElementById('restart-btn').style.display = 'inline-block';
}

function spawnExplosion(x, y, hit) {
  const count = hit ? 48 : 22;
  const hitColors = ['#f5a020','#ffcc00','#ff6010','#e83000','#c8a000','#ffffff','#ffe080','#5a7a10'];
  const missColors = ['#7a5820','#c89040','#a87030','#8a6028','#5a3a10'];
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 40 + Math.random() * (hit ? 140 : 80);
    const colorPool = hit ? hitColors : missColors;
    state.particulas.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - (hit ? 80 : 30),
      life: 1,
      decay: 0.5 + Math.random() * 0.9,
      color: colorPool[Math.floor(Math.random() * colorPool.length)],
      size: hit ? (3 + Math.random() * 5) : (2 + Math.random() * 3),
    });
  }
  // Add water droplets on hit
  if (hit) {
    for (let i = 0; i < 16; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 20 + Math.random() * 60;
      state.particulas.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 40,
        life: 1,
        decay: 0.7 + Math.random() * 0.5,
        color: ['#38b8e8','#a8e4f8','#1888c0'][Math.floor(Math.random() * 3)],
        size: 2 + Math.random() * 3,
      });
    }
  }
}

function updateParticulas(dt) {
  for (let i = state.particulas.length - 1; i >= 0; i--) {
    const p = state.particulas[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 80 * dt;
    p.life -= p.decay * dt;
    if (p.life <= 0) state.particulas.splice(i, 1);
  }
}

// DIBUJO
function draw() {
  ctx.clearRect(0, 0, CV_W, CV_H);

  drawSky();
  drawHills();
  drawGround();
  drawTarget();
  drawButt();
  drawTrail();
  drawProjectile();
  drawParticulas();
  if (state.gameOver) drawOverlay();
}

function drawHills() {
  // Helper: draw a filled hill silhouette using quadratic curves
  function hillLayer(pts, fillColor, shadowColor) {
    ctx.beginPath();
    ctx.moveTo(0, CV_H);
    ctx.lineTo(0, pts[0].y);
    for (let i = 0; i < pts.length - 1; i++) {
      const mx = (pts[i].x + pts[i + 1].x) / 2;
      const my = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(pts[i].x, pts[i].y, mx, my);
    }
    const last = pts[pts.length - 1];
    ctx.lineTo(last.x, last.y);
    ctx.lineTo(CV_W, last.y);
    ctx.lineTo(CV_W, CV_H);
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();

    // Thin bright highlight stripe along crest
    ctx.beginPath();
    ctx.moveTo(0, pts[0].y);
    for (let i = 0; i < pts.length - 1; i++) {
      const mx = (pts[i].x + pts[i + 1].x) / 2;
      const my = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(pts[i].x, pts[i].y, mx, my);
    }
    const lastH = pts[pts.length - 1];
    ctx.lineTo(lastH.x, lastH.y);
    ctx.strokeStyle = shadowColor;
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Layer 1 ‚Äî distant pink/mauve mountains (tall, sharp)
  hillLayer([
    {x:0,   y:310}, {x:100, y:220}, {x:210, y:300}, {x:320, y:190},
    {x:430, y:270}, {x:560, y:200}, {x:680, y:290}, {x:800, y:210},
    {x:920, y:300}, {x:1060,y:195}, {x:1180,y:280}, {x:1300,y:210},
    {x:1400,y:300},
  ], '#c47898', '#e098b8');

  // Layer 2 ‚Äî mid purple-pink hills (rounder)
  hillLayer([
    {x:0,   y:350}, {x:120, y:295}, {x:250, y:340}, {x:390, y:280},
    {x:520, y:345}, {x:650, y:295}, {x:790, y:350}, {x:940, y:290},
    {x:1080,y:345}, {x:1220,y:295}, {x:1350,y:340}, {x:1400,y:320},
  ], '#b07ab8', '#cc9acc');

  // Layer 3 ‚Äî near bright green hills
  hillLayer([
    {x:0,   y:395}, {x:140, y:355}, {x:290, y:388}, {x:440, y:348},
    {x:590, y:390}, {x:730, y:352}, {x:870, y:393}, {x:1010,y:350},
    {x:1150,y:392}, {x:1280,y:358}, {x:1400,y:395},
  ], '#5eaa2e', '#80cc50');

  // Layer 4 ‚Äî foreground dark green low bumps
  hillLayer([
    {x:0,   y:425}, {x:160, y:405}, {x:330, y:422}, {x:500, y:402},
    {x:670, y:428}, {x:840, y:404}, {x:1000,y:426}, {x:1160,y:406},
    {x:1320,y:424}, {x:1400,y:412},
  ], '#3d8820', '#5aa830');
}

function drawSky() {
  const grad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  grad.addColorStop(0,    '#2a7fc7');
  grad.addColorStop(0.35, '#4ab8f0');
  grad.addColorStop(0.75, '#8ed4f5');
  grad.addColorStop(1,    '#c6eefa');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, CV_W, GROUND_Y);

  // A few soft clouds
  ctx.fillStyle = 'rgba(255,255,255,0.62)';
  const clouds = [
    [160, 60, 80, 22], [380, 40, 110, 28], [620, 80, 90, 20],
    [900, 55, 130, 32], [1150, 70, 95, 24], [1320, 45, 75, 18],
  ];
  for (const [cx2, cy2, w, h] of clouds) {
    ctx.beginPath();
    ctx.ellipse(cx2,      cy2,      w * 0.5, h * 0.5,  0, 0, Math.PI * 2);
    ctx.ellipse(cx2 + 28, cy2 - 10, w * 0.35, h * 0.6, 0, 0, Math.PI * 2);
    ctx.ellipse(cx2 - 24, cy2 - 6,  w * 0.3,  h * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawGround() {
  // Dark soil base (bottom fill)
  ctx.fillStyle = '#3d2010';
  ctx.fillRect(0, GROUND_Y + 30, CV_W, CV_H - GROUND_Y - 30);

  // Brown earth layer
  ctx.fillStyle = '#7a4820';
  ctx.fillRect(0, GROUND_Y + 14, CV_W, 20);

  // Pebble/rock texture in brown layer
  ctx.fillStyle = '#5c3412';
  for (let x = 12; x < CV_W; x += 48) {
    ctx.beginPath();
    ctx.ellipse(x, GROUND_Y + 22, 5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x + 24, GROUND_Y + 28, 4, 2, 0.4, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.fillStyle = '#8a5830';
  for (let x = 30; x < CV_W; x += 60) {
    ctx.beginPath();
    ctx.ellipse(x, GROUND_Y + 18, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Dark green sub-grass layer
  ctx.fillStyle = '#2e6a14';
  ctx.fillRect(0, GROUND_Y + 10, CV_W, 10);

  // Bright grass top ‚Äî wavy using quadratic curves
  const waveAmp = 5;
  const waveFreq = 80;
  ctx.beginPath();
  ctx.moveTo(0, CV_H);
  ctx.lineTo(0, GROUND_Y + waveAmp);
  for (let x = 0; x <= CV_W; x += waveFreq) {
    const y1 = GROUND_Y + Math.sin((x / CV_W) * Math.PI * 8 + 0.3) * waveAmp;
    const y2 = GROUND_Y + Math.sin(((x + waveFreq / 2) / CV_W) * Math.PI * 8 + 0.3) * waveAmp;
    ctx.quadraticCurveTo(x + waveFreq / 4, y1 - 3, x + waveFreq / 2, y2);
    ctx.quadraticCurveTo(x + waveFreq * 3 / 4, y2 + 3, x + waveFreq, GROUND_Y + Math.sin(((x + waveFreq) / CV_W) * Math.PI * 8 + 0.3) * waveAmp);
  }
  ctx.lineTo(CV_W, CV_H);
  ctx.closePath();
  ctx.fillStyle = '#4db825';
  ctx.fill();

  // Grass highlight stripe
  ctx.strokeStyle = '#72dd40';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y - 1);
  for (let x = 0; x <= CV_W; x += waveFreq) {
    const y1 = GROUND_Y + Math.sin((x / CV_W) * Math.PI * 8 + 0.3) * waveAmp - 2;
    ctx.quadraticCurveTo(x + waveFreq / 2, y1 - 4, x + waveFreq, GROUND_Y + Math.sin(((x + waveFreq) / CV_W) * Math.PI * 8 + 0.3) * waveAmp - 2);
  }
  ctx.stroke();

  // Small grass blades (decorative tufts)
  ctx.fillStyle = '#3aaa18';
  for (let x = 20; x < CV_W; x += 38) {
    const gy = GROUND_Y - 2;
    ctx.fillRect(x,     gy - 5, 2, 5);
    ctx.fillRect(x + 6, gy - 7, 2, 7);
    ctx.fillRect(x + 12, gy - 4, 2, 4);
  }
}

function drawButt() {
  const cx = CANNON_X;
  const cy = GROUND_Y;
  const a = (state.angulo || 45);

  // Shadow under butt
  ctx.fillStyle = 'rgba(0,0,0,0.22)';
  ctx.beginPath();
  ctx.ellipse(cx, cy, 34, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // LEFT cheek ‚Äî highlight band
  ctx.fillStyle = '#ffdfc4';
  ctx.fillRect(cx - 36, cy - 44, 32, 6);
  // LEFT cheek ‚Äî main body
  ctx.fillStyle = '#f0c8a0';
  ctx.fillRect(cx - 36, cy - 38, 32, 38);
  // LEFT cheek ‚Äî shadow band right edge
  ctx.fillStyle = '#c89870';
  ctx.fillRect(cx - 8,  cy - 38, 6, 38);
  // LEFT cheek ‚Äî bottom shadow
  ctx.fillStyle = '#b87a58';
  ctx.fillRect(cx - 36, cy - 6, 32, 6);

  // RIGHT cheek ‚Äî highlight band
  ctx.fillStyle = '#ffdfc4';
  ctx.fillRect(cx + 4, cy - 44, 32, 6);
  // RIGHT cheek ‚Äî main body
  ctx.fillStyle = '#f0c8a0';
  ctx.fillRect(cx + 4, cy - 38, 32, 38);
  // RIGHT cheek ‚Äî shadow band right edge
  ctx.fillStyle = '#c89870';
  ctx.fillRect(cx + 30, cy - 38, 6, 38);
  // RIGHT cheek ‚Äî bottom shadow
  ctx.fillStyle = '#b87a58';
  ctx.fillRect(cx + 4, cy - 6, 32, 6);

  // Center crack
  ctx.fillStyle = '#a06040';
  ctx.fillRect(cx - 4, cy - 44, 8, 44);
  ctx.fillStyle = '#7a4020';
  ctx.fillRect(cx - 2, cy - 42, 4, 40);

  // Dimples (highlight dots)
  ctx.fillStyle = '#ffeedd';
  ctx.fillRect(cx - 24, cy - 32, 6, 4);
  ctx.fillRect(cx + 18, cy - 32, 6, 4);

  // Skin fold lines
  ctx.fillStyle = '#c89070';
  ctx.fillRect(cx - 30, cy - 18, 20, 2);
  ctx.fillRect(cx + 10, cy - 18, 20, 2);

  // Base/seat band
  ctx.fillStyle = '#8a5838';
  ctx.fillRect(cx - 38, cy - 7, 76, 7);
  ctx.fillStyle = '#6a3820';
  ctx.fillRect(cx - 38, cy - 2, 76, 2);

  // Cannon nozzle (rotated)
  ctx.save();
  ctx.translate(cx, cy - 26);
  ctx.rotate(-a * Math.PI / 180);

  // Cannon barrel ‚Äî main body
  ctx.fillStyle = '#7a3040';
  ctx.fillRect(0, -6, 36, 12);
  // Barrel highlight top
  ctx.fillStyle = '#a05070';
  ctx.fillRect(0, -6, 36, 3);
  // Barrel shadow bottom
  ctx.fillStyle = '#501020';
  ctx.fillRect(0, 3, 36, 3);
  // Muzzle ring
  ctx.fillStyle = '#c06080';
  ctx.fillRect(32, -8, 6, 16);
  ctx.fillStyle = '#802040';
  ctx.fillRect(34, -9, 4, 18);
  // Muzzle hole
  ctx.fillStyle = '#200810';
  ctx.fillRect(35, -3, 5, 6);
  // Cannon band / strap
  ctx.fillStyle = '#601830';
  ctx.fillRect(12, -7, 5, 14);

  ctx.restore();

  // Gas cloud when charging (idle puff)
  if (state.charging || (state.fase === 'apuntando' && !state.gameOver)) {
    const t = Date.now() / 400;
    const puffAlpha = 0.18 + 0.12 * Math.sin(t);
    ctx.fillStyle = `rgba(160,220,80,${puffAlpha})`;
    ctx.beginPath();
    ctx.ellipse(cx + 6, cy - 50, 14, 10, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 16, cy - 58, 10, 8, 0.2, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawTarget() {
  if (!state.distObj) return;
  const tx = worldToScreen(state.distObj);

  if (state.objDestruido) {
    // Ruinas del inodoro (debris scattered on ground)
    const rx = Math.round(tx);
    ctx.fillStyle = '#99aabb';
    ctx.fillRect(rx - 22, GROUND_Y - 10, 16, 10);
    ctx.fillRect(rx + 8,  GROUND_Y - 8,  14, 8);
    ctx.fillStyle = '#667788';
    ctx.fillRect(rx - 14, GROUND_Y - 6,  8,  4);
    ctx.fillRect(rx + 12, GROUND_Y - 5,  7,  3);
    ctx.fillStyle = '#aaccee';
    ctx.fillRect(rx - 6,  GROUND_Y - 4,  5,  3);
    // Small water puddle
    ctx.fillStyle = 'rgba(60,160,220,0.35)';
    ctx.beginPath();
    ctx.ellipse(rx, GROUND_Y - 1, 18, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    return;
  }

  const floatY = Math.sin(Date.now() / 700) * 10;
  const cx = Math.round(tx);
  const cy = Math.round(GROUND_Y - 80 + floatY); // base del inodoro (higher up ‚Äî larger canvas)

  // Shadow on ground
  const sa = (0.18 + 0.08 * Math.sin(Date.now() / 700));
  ctx.fillStyle = `rgba(0,0,0,${sa.toFixed(2)})`;
  ctx.beginPath();
  ctx.ellipse(cx, GROUND_Y - 3, 28, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // ====== ANGEL WINGS (white, 32-bit style) ======
  // Each wing: 5 feather rows, each row has 3 individual feather tips
  // Wing shape arcs upward from body center

  function drawWing(side) {
    const s = side; // 1 = right, -1 = left
    const base = s === 1 ? cx + 12 : cx - 12;

    // Wing rows ‚Äî from bottom (small) to top (large)
    const rows = [
      { dy: -10, feathers: [{w:14,h:9},{w:12,h:8},{w:10,h:7}],  gap: 2, arc: 0  },
      { dy: -20, feathers: [{w:18,h:11},{w:16,h:10},{w:13,h:9}], gap: 2, arc: 6  },
      { dy: -32, feathers: [{w:22,h:13},{w:20,h:12},{w:16,h:10}],gap: 2, arc: 12 },
      { dy: -45, feathers: [{w:26,h:14},{w:24,h:13},{w:18,h:11}],gap: 2, arc: 16 },
      { dy: -58, feathers: [{w:28,h:13},{w:25,h:12},{w:19,h:10}],gap: 2, arc: 14 },
    ];

    for (const row of rows) {
      let xOff = s * (row.arc);
      for (let fi = 0; fi < row.feathers.length; fi++) {
        const f = row.feathers[fi];
        const fx = base + s * (fi * (f.w + row.gap)) + xOff;
        const fy = cy + row.dy;

        // Feather shadow base
        ctx.fillStyle = '#b8c8d8';
        ctx.fillRect(
          s === 1 ? fx : fx - f.w,
          fy + 2, f.w, f.h
        );
        // Feather body
        ctx.fillStyle = '#e8f4fc';
        ctx.fillRect(
          s === 1 ? fx : fx - f.w,
          fy, f.w, f.h - 2
        );
        // Feather highlight top
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(
          s === 1 ? fx : fx - f.w,
          fy, f.w, 3
        );
        // Feather quill line
        ctx.fillStyle = '#c8dce8';
        ctx.fillRect(
          s === 1 ? fx + Math.floor(f.w / 2) : fx - Math.floor(f.w / 2) - 1,
          fy + 2, 1, f.h - 4
        );
        // Feather dark tip outline
        ctx.fillStyle = '#8aaabb';
        ctx.fillRect(
          s === 1 ? fx : fx - f.w,
          fy + f.h - 2, f.w, 2
        );
      }
    }

    // Wing base attachment (feather root, connects to toilet body)
    ctx.fillStyle = '#d0e8f8';
    ctx.fillRect(
      s === 1 ? cx + 10 : cx - 18,
      cy - 48, 8, 40
    );
    ctx.fillStyle = '#a8c4d8';
    ctx.fillRect(
      s === 1 ? cx + 15 : cx - 18,
      cy - 48, 3, 40
    );
  }

  drawWing(-1); // left wing
  drawWing(1);  // right wing

  // ====== TOILET BODY (porcelain 32-bit) ======
  const W   = '#dff0fa'; // porcelain white
  const WH  = '#f4fafe'; // highlight white
  const LG  = '#a8c4d8'; // shadow grey
  const DK  = '#1a3040'; // dark outline
  const TL  = '#38b8e8'; // water blue
  const T2  = '#1888c0'; // water dark
  const T3  = '#a8e4f8'; // water highlight

  // BASE (pedestal foot)
  ctx.fillStyle = DK;
  ctx.fillRect(cx - 12, cy - 16, 24, 16);
  ctx.fillStyle = W;
  ctx.fillRect(cx - 11, cy - 15, 22, 15);
  ctx.fillStyle = WH;
  ctx.fillRect(cx - 11, cy - 15, 22, 4);
  ctx.fillStyle = LG;
  ctx.fillRect(cx + 9,  cy - 15, 2, 15);

  // BOWL (seat area)
  ctx.fillStyle = DK;
  ctx.fillRect(cx - 16, cy - 48, 32, 34);
  ctx.fillStyle = W;
  ctx.fillRect(cx - 15, cy - 47, 30, 32);
  ctx.fillStyle = WH;
  ctx.fillRect(cx - 15, cy - 47, 30, 5); // highlight rim
  ctx.fillStyle = LG;
  ctx.fillRect(cx + 13, cy - 47, 2,  32); // shadow right
  ctx.fillRect(cx - 15, cy - 17, 30, 3);  // shadow bottom rim

  // Bowl seat ring
  ctx.fillStyle = LG;
  ctx.fillRect(cx - 15, cy - 47, 30, 2);

  // Inner bowl hole
  ctx.fillStyle = DK;
  ctx.fillRect(cx - 12, cy - 44, 24, 22);
  // Water
  ctx.fillStyle = TL;
  ctx.fillRect(cx - 11, cy - 43, 22, 20);
  // Water highlight
  ctx.fillStyle = T3;
  ctx.fillRect(cx - 10, cy - 43, 10, 4);
  ctx.fillRect(cx - 9,  cy - 40, 6,  2);
  // Water dark band
  ctx.fillStyle = T2;
  ctx.fillRect(cx - 10, cy - 25, 20, 4);

  // TANK
  ctx.fillStyle = DK;
  ctx.fillRect(cx - 13, cy - 80, 26, 34);
  ctx.fillStyle = W;
  ctx.fillRect(cx - 12, cy - 79, 24, 32);
  ctx.fillStyle = WH;
  ctx.fillRect(cx - 12, cy - 79, 24, 6);
  ctx.fillStyle = LG;
  ctx.fillRect(cx + 10, cy - 79, 2,  32);

  // Tank lid
  ctx.fillStyle = DK;
  ctx.fillRect(cx - 14, cy - 83, 28, 5);
  ctx.fillStyle = W;
  ctx.fillRect(cx - 13, cy - 82, 26, 4);
  ctx.fillStyle = WH;
  ctx.fillRect(cx - 13, cy - 82, 26, 2);

  // Handle knob on tank
  ctx.fillStyle = LG;
  ctx.fillRect(cx - 2,  cy - 88, 4,  5);
  ctx.fillRect(cx - 4,  cy - 89, 8,  2);
  ctx.fillStyle = WH;
  ctx.fillRect(cx - 1,  cy - 88, 2,  2);

  // Small reflection shine on bowl
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fillRect(cx - 13, cy - 46, 6, 2);
  ctx.fillRect(cx - 13, cy - 44, 3, 2);

  // Distance label
  ctx.fillStyle = '#44aaff';
  ctx.font = 'bold 13px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(Math.round(state.distObj) + 'm', cx, cy - 98);
}

function drawTrail() {
  if (!state.proj) return;
  for (let i = 0; i < state.proj.trail.length; i++) {
    const p = state.proj.trail[i];
    const frac = i / state.proj.trail.length;
    const alpha = frac * 0.7;
    const size  = 1 + Math.round(frac * 3);
    ctx.fillStyle = `rgba(180, 100, 30, ${alpha.toFixed(2)})`;
    ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
  }
}

function drawProjectile() {
  if (!state.proj) return;
  const p = state.proj;
  const x = Math.round(p.x);
  const y = Math.round(p.y);

  // Poop projectile ‚Äî 32-bit, rounder and more detailed
  // Dark outline
  ctx.fillStyle = '#3a1a08';
  ctx.fillRect(x - 7, y + 1,  14, 4);
  ctx.fillRect(x - 6, y - 3,  12, 5);
  ctx.fillRect(x - 4, y - 7,   8, 5);
  ctx.fillRect(x - 3, y - 10,  6, 4);
  ctx.fillRect(x - 2, y - 13,  4, 4);
  ctx.fillRect(x - 1, y - 15,  2, 3);

  // Main brown body
  ctx.fillStyle = '#7a3c10';
  ctx.fillRect(x - 6, y + 1,  12, 3);
  ctx.fillRect(x - 5, y - 2,  10, 4);
  ctx.fillRect(x - 3, y - 6,   6, 4);
  ctx.fillRect(x - 2, y - 9,   4, 3);
  ctx.fillRect(x - 1, y - 12,  2, 3);

  // Warm mid-tone
  ctx.fillStyle = '#c87840';
  ctx.fillRect(x - 4, y + 1,   5, 2);
  ctx.fillRect(x - 3, y - 2,   4, 3);
  ctx.fillRect(x - 2, y - 5,   3, 3);

  // Highlight dot
  ctx.fillStyle = '#e8a860';
  ctx.fillRect(x - 3, y,       3, 2);
  ctx.fillRect(x - 2, y - 3,   2, 2);

  // Tiny shine
  ctx.fillStyle = '#ffe0a8';
  ctx.fillRect(x - 2, y - 1,   2, 1);

  // Swirl curl lines (dark)
  ctx.fillStyle = '#5a2808';
  ctx.fillRect(x,     y - 4,   2, 1);
  ctx.fillRect(x - 1, y - 6,   3, 1);
}

function drawParticulas() {
  for (const p of state.particulas) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    const s = Math.ceil(p.size);
    ctx.fillRect(Math.round(p.x) - s/2, Math.round(p.y) - s/2, s, s);
  }
  ctx.globalAlpha = 1;
}

function drawOverlay() {
  ctx.fillStyle = state.victoria ? 'rgba(0,60,0,0.55)' : 'rgba(80,0,0,0.55)';
  ctx.fillRect(0, 0, CV_W, CV_H);
  const msg = state.victoria ? '¬°VICTORIA!' : 'DERROTA';
  ctx.font = 'bold 72px monospace';
  ctx.textAlign = 'center';
  // Shadow
  ctx.fillStyle = state.victoria ? '#806010' : '#800000';
  ctx.fillText(msg, CV_W / 2 + 4, CV_H / 2 + 4);
  // Main text
  ctx.fillStyle = state.victoria ? '#f5c542' : '#ff4444';
  ctx.fillText(msg, CV_W / 2, CV_H / 2);
  // Sub text
  ctx.font = '28px monospace';
  ctx.fillStyle = '#e8e8e8';
  ctx.fillText(state.victoria ? 'üí© Todo embarrado' : 'üí® P√≥lvora desperdiciada', CV_W / 2, CV_H / 2 + 60);
}

// Bucle idle: actualiza potencia y redibuja mientras no hay animaci√≥n activa
function idleDraw() {
  if (!animating) {
    // Actualizar potencia si est√° cargando en idle
    if (state.charging && state.chargeStart !== null) {
      const elapsed = (Date.now() - state.chargeStart) / 1000;
      state.power = Math.min(elapsed / 1.25, 1.0);
      updatePowerBar();
    }
    draw();
    requestAnimationFrame(idleDraw);
  }
}

// ‚îÄ‚îÄ AUDIO (Web Audio API ‚Äî procedural) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let audioCtx = null;
function getAC() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function soundFire() {
  const ac = getAC();
  const bufLen = Math.round(ac.sampleRate * 0.25);
  const buf = ac.createBuffer(1, bufLen, ac.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;

  const src = ac.createBufferSource();
  src.buffer = buf;

  const filter = ac.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.setValueAtTime(300, ac.currentTime);
  filter.frequency.exponentialRampToValueAtTime(80, ac.currentTime + 0.25);
  filter.Q.value = 1.5;

  const gain = ac.createGain();
  gain.gain.setValueAtTime(0.7, ac.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.25);

  src.connect(filter);
  filter.connect(gain);
  gain.connect(ac.destination);
  src.start();
  src.stop(ac.currentTime + 0.25);
}

function soundHit() {
  const ac = getAC();
  const now = ac.currentTime;

  // Splash: noise lowpass descendente
  const bufLen = Math.round(ac.sampleRate * 0.4);
  const buf = ac.createBuffer(1, bufLen, ac.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;

  const src = ac.createBufferSource();
  src.buffer = buf;

  const filt = ac.createBiquadFilter();
  filt.type = 'lowpass';
  filt.frequency.setValueAtTime(800, now);
  filt.frequency.exponentialRampToValueAtTime(100, now + 0.4);

  const gSplash = ac.createGain();
  gSplash.gain.setValueAtTime(0.6, now);
  gSplash.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

  src.connect(filt);
  filt.connect(gSplash);
  gSplash.connect(ac.destination);
  src.start(now);
  src.stop(now + 0.4);

  // Flush: oscilador square retardado (cisterna)
  const osc = ac.createOscillator();
  osc.type = 'square';
  osc.frequency.setValueAtTime(600, now + 0.1);
  osc.frequency.exponentialRampToValueAtTime(200, now + 0.5);

  const gFlush = ac.createGain();
  gFlush.gain.setValueAtTime(0, now);
  gFlush.gain.setValueAtTime(0.35, now + 0.1);
  gFlush.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

  osc.connect(gFlush);
  gFlush.connect(ac.destination);
  osc.start(now + 0.1);
  osc.stop(now + 0.5);
}

function soundMiss() {
  const ac = getAC();
  const now = ac.currentTime;

  // Thud: sine grave descendente
  const osc = ac.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(120, now);
  osc.frequency.exponentialRampToValueAtTime(30, now + 0.3);

  const gThud = ac.createGain();
  gThud.gain.setValueAtTime(0.8, now);
  gThud.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

  osc.connect(gThud);
  gThud.connect(ac.destination);
  osc.start(now);
  osc.stop(now + 0.3);

  // Textura: noise corto lowpass
  const bufLen = Math.round(ac.sampleRate * 0.15);
  const buf = ac.createBuffer(1, bufLen, ac.sampleRate);
  const noiseData = buf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) noiseData[i] = Math.random() * 2 - 1;

  const src = ac.createBufferSource();
  src.buffer = buf;

  const filt = ac.createBiquadFilter();
  filt.type = 'lowpass';
  filt.frequency.value = 400;

  const gNoise = ac.createGain();
  gNoise.gain.setValueAtTime(0.4, now);
  gNoise.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

  src.connect(filt);
  filt.connect(gNoise);
  gNoise.connect(ac.destination);
  src.start(now);
  src.stop(now + 0.15);
}

function soundVictory() {
  const ac = getAC();
  const notes = [523, 659, 784]; // C5, E5, G5
  notes.forEach((freq, i) => {
    const t = ac.currentTime + i * 0.15;
    const osc = ac.createOscillator();
    osc.type = 'square';
    osc.frequency.value = freq;

    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.35, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

    osc.connect(g);
    g.connect(ac.destination);
    osc.start(t);
    osc.stop(t + 0.15);
  });
}

function soundDefeat() {
  const ac = getAC();
  const notes = [392, 330, 277]; // G4, E4, Db4
  notes.forEach((freq, i) => {
    const t = ac.currentTime + i * 0.2;
    const osc = ac.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

    osc.connect(g);
    g.connect(ac.destination);
    osc.start(t);
    osc.stop(t + 0.2);
  });
}

// Eventos ‚Äî bot√≥n fuego: mousedown inicia carga, mouseup en document dispara
const fireBtn = document.getElementById('fire-btn');

fireBtn.addEventListener('mousedown', (e) => {
  e.preventDefault();
  startCharge();
});

// mouseup en document para capturar la suelta aunque el cursor salga del bot√≥n
document.addEventListener('mouseup', (e) => {
  if (state.charging) {
    releaseAndFire();
  }
});

// Flechas arriba/abajo para el √°ngulo
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    e.preventDefault();
    const input = document.getElementById('angle-input');
    let val = parseFloat(input.value) || 45;
    val = e.key === 'ArrowUp' ? Math.min(val + 1, 89) : Math.max(val - 1, 1);
    input.value = val;
    state.angulo = val;
  }
});

// Espaciadora
document.addEventListener('keydown', (e) => {
  if (e.key === ' ' || e.code === 'Space') {
    e.preventDefault();
    startCharge();
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === ' ' || e.code === 'Space') {
    e.preventDefault();
    releaseAndFire();
  }
});

document.getElementById('angle-input').addEventListener('input', () => {
  state.angulo = parseFloat(document.getElementById('angle-input').value) || 45;
});

document.getElementById('angle-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    // Enter en el input tambi√©n dispara (si ya estaba cargando, suelta; si no, carga y suelta r√°pido)
    if (!state.charging) startCharge();
    releaseAndFire();
  }
});

document.getElementById('restart-btn').addEventListener('click', () => {
  document.getElementById('restart-btn').style.display = 'none';
  initGame();
  animating = false;
  requestAnimationFrame(idleDraw);
});

// Inicio
initGame();
requestAnimationFrame(idleDraw);
</script>
</body>
</html>
